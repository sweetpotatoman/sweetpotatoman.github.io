(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{356:function(e,s,n){"use strict";n.r(s);var a=n(9),t=Object(a.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),n("p",[e._v("使用 Jenkins 做持续集成/持续交付，当业务达到一定规模的时候，Jenkins 本身就很容易成为整条流水线的瓶颈，各个业务端都依靠 Jenkins，部署 Jenkins 服务时如何保障服务的高可用变得尤为重要。")]),e._v(" "),n("p",[e._v("以我公司为例，由于目前服务，开发和测试环境都在国内，而 UAT 和线上环境都在国外。所以光靠一个地区的 Master 节点无法满足两地的需求，也考虑到日后会有高并发的性能压力，瓶颈会来自多方面，严重影响整个技术团队的工作效率和部署节奏之前，需要在"),n("code",[e._v("国内国外设置 jenkins slave")])]),e._v(" "),n("h3",{attrs:{id:"jenkins-分布式集群架构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jenkins-分布式集群架构"}},[e._v("#")]),e._v(" Jenkins 分布式集群架构")]),e._v(" "),n("p",[e._v("Jenkins 分布式架构是由一个 Master 和多个 Slave Node 组成的分布式架构。在 Jenkins Master 上管理你的项目，可以把你的一些构建任务分担到不同的 Slave Node 上运行，Master 的性能就提高了。"),n("br"),e._v("\nMaster/Slave 相当于 Server 和 agent 的概念。Master提供 web 接口让用户来管理 job 和 slave，job 可以运行在 master 本机或者被分配到 slave 上运行构建。"),n("br"),e._v("\n一个 master（jenkins服务所在机器）可以关联多个 slave 用来为不同的 job 或相同的 job 的不同配置来服务。")]),e._v(" "),n("h4",{attrs:{id:"传统的-jenkins-slave-一主多从式会存在一些痛点。比如"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#传统的-jenkins-slave-一主多从式会存在一些痛点。比如"}},[e._v("#")]),e._v(" 传统的 Jenkins Slave 一主多从式会存在一些痛点。比如:")]),e._v(" "),n("ul",[n("li",[e._v("主 Master 发生单点故障时，整个流程都不可用了；")]),e._v(" "),n("li",[e._v("每个 Slave 的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置导致管理起来非常不方便，维护起来也是比较费劲；")]),e._v(" "),n("li",[e._v("资源分配不均衡，有的 Slave 要运行的 job 出现排队等待，而有的 Slave 处于空闲状态；")]),e._v(" "),n("li",[e._v("资源有浪费，每台 Slave 可能是实体机或者 VM，当 Slave 处于空闲状态时，也不会完全释放掉资源。")])]),e._v(" "),n("h4",{attrs:{id:"由于传统的高可用方式弊端过多，需使用基于-kubernetes-搭建容器化-jenkins-集群的方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#由于传统的高可用方式弊端过多，需使用基于-kubernetes-搭建容器化-jenkins-集群的方式"}},[e._v("#")]),e._v(" 由于传统的高可用方式弊端过多，需使用基于 "),n("code",[e._v("Kubernetes")]),e._v(" 搭建容器化 Jenkins 集群的方式")]),e._v(" "),n("p",[e._v("下图是基于 Kubernetes 搭建 Jenkins 集群的简单示意图：\n")]),n("div",{staticStyle:{"text-align":"center"}},[n("img",{attrs:{src:"/image/jenkins-ha.png"}})]),n("p"),e._v(" "),n("p",[e._v("Jenkins Master 和 Jenkins Slave 以 Docker Container 形式运行在 Kubernetes 集群的 Node 上，Master 运行在其中一个集群中，并且将其"),n("code",[e._v("配置数据存储到一个 Volume [NFS or ...]")]),e._v(" 上去，Slave 运行在各个节点上，并且它不是一直处于运行状态，它会按照需求"),n("code",[e._v("动态的创建并自动删除")])]),e._v(" "),n("h4",{attrs:{id:"这种方式带来的好处"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#这种方式带来的好处"}},[e._v("#")]),e._v(" 这种方式带来的好处")]),e._v(" "),n("ul",[n("li",[e._v("服务高可用，当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失")]),e._v(" "),n("li",[e._v("动态伸缩，合理使用资源，每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。")]),e._v(" "),n("li",[e._v("扩展性好，当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。")])])])}),[],!1,null,null,null);s.default=t.exports}}]);